#!/usr/bin/env python3
"""
Script para detectar valores crÃ­ticos expuestos en repositorios.
Busca patrones comunes de API keys, tokens, contraseÃ±as, etc.

Uso:
    python3 detect-secrets.py /ruta/local
    python3 detect-secrets.py https://github.com/usuario/repo.git
    python3 detect-secrets.py https://gitlab.com/usuario/repo.git
"""

import os
import re
import json
import sys
import subprocess
import tempfile
import shutil
import requests
from pathlib import Path
from datetime import datetime
from urllib.parse import urlparse

# Patrones de detecciÃ³n de secretos
PATTERNS = {
    'API_KEYS': [
        r'(?i)api[_-]?key\s*[:=]\s*["\']?([a-zA-Z0-9\-_]{20,})["\']?',
    ],
    'AWS_CREDENTIALS': [
        r'(?i)(AKIA[0-9A-Z]{16})',
        r'(?i)aws[_-]?access[_-]?key[_-]?id\s*[:=]\s*["\']?([A-Z0-9]{20})',
    ],
    'GCP_CREDENTIALS': [
        r'(?i)["\']?type["\']?\s*[:=]\s*["\']service_account["\']',
        r'(?i)["\']?project_id["\']?\s*[:=]\s*["\']([a-z0-9-]+)["\']',
        r'(?i)["\']?private_key["\']?\s*[:=]\s*["\']?-----BEGIN PRIVATE KEY-----',
    ],
    'DATABASE_CREDENTIALS': [
        r'(?i)db[_-]?password\s*[:=]\s*["\']?([^"\':\s]{8,})["\']?',
        r'(?i)password\s*[:=]\s*["\']?([^"\':\s]{8,})["\']?',
    ],
    'TOKENS': [
        r'(?i)token\s*[:=]\s*["\']?([a-zA-Z0-9_.]{32,})["\']?',
        r'(?i)github[_-]?token\s*[:=]\s*["\']?([a-zA-Z0-9_]{36,})["\']?',
        r'(?i)jwt\s*[:=]\s*["\']?([a-zA-Z0-9_.]+)["\']?',
    ],
    'PRIVATE_KEYS': [
        r'-----BEGIN (RSA |DSA |EC )?PRIVATE KEY-----',
        r'-----BEGIN OPENSSH PRIVATE KEY-----',
        r'(?i)private[_-]?key\s*[:=]\s*["\']?-----BEGIN',
    ],
    'ENCRYPTION_KEYS': [
        r'(?i)encripcion[_-]?key\s*[:=]\s*["\']?([a-zA-Z0-9#\*\+_\-]{16,})["\']?',
        r'(?i)secret[_-]?key\s*[:=]\s*["\']?([a-zA-Z0-9_#\*\+\-]{16,})["\']?',
        r'(?i)encryption[_-]?key\s*[:=]\s*["\']?([a-zA-Z0-9_]{32,})["\']?',
        r'(?i)encripcion[_-]?iv\s*[:=]\s*["\']?([a-zA-Z0-9\*\+_\-]+)["\']?',
        r'(?i)key\s*[:=]\s*["\']?([a-zA-Z0-9#\*\+_\-]{32,})["\']?',
    ],
    'CUSTOM_PATTERNS': [
        r'(?i)crm[_-]?key\s*[:=]\s*["\']?([a-zA-Z0-9]{32,})["\']?',
        r'(?i)x[_-]?api[_-]?key\s*[:=]\s*["\']?([a-zA-Z0-9_]{20,})["\']?',
        r'l7xx[a-zA-Z0-9]{30,}',
    ]
}

# Archivos/directorios a excluir
EXCLUDED_PATTERNS = [
    r'\.git',
    r'\.gitignore',
    r'node_modules',
    r'\.node-red',
    r'__pycache__',
    r'\.pytest_cache',
    r'\.venv',
    r'venv',
    r'\.env\.example',
    r'\.env\.template',
    r'package-lock\.json',
    r'yarn\.lock',
    r'\.pyc',
    r'\.class',
    r'\.jar',
    r'\.zip',
    r'\.tar\.gz',
    r'\.png',
    r'\.jpg',
    r'\.pdf',
    r'\.docx',
    r'dist',
    r'build',
    r'coverage',
    r'\.DS_Store',
    r'Thumbs\.db',
]

def should_skip_file(file_path):
    """Determina si un archivo debe ser ignorado."""
    path_str = str(file_path)
    
    for excluded in EXCLUDED_PATTERNS:
        if re.search(excluded, path_str):
            return True
    
    return False

def detect_secrets_in_file(file_path):
    """Detecta secretos en un archivo."""
    findings = []
    seen = set()  # Para deduplicar hallazgos
    
    try:
        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
            lines = f.readlines()
    except Exception as e:
        return findings
    
    for line_num, line in enumerate(lines, 1):
        for secret_type, patterns in PATTERNS.items():
            for pattern in patterns:
                matches = re.finditer(pattern, line)
                for match in matches:
                    # Evitar falsos positivos en comentarios obvios
                    if 'example' not in line.lower() and 'test' not in line.lower():
                        # Deduplicar: mismo archivo, lÃ­nea y contenido
                        dedup_key = (line_num, line.strip())
                        
                        if dedup_key not in seen:
                            seen.add(dedup_key)
                            findings.append({
                                'line': line_num,
                                'type': secret_type,
                                'pattern': pattern[:50] + '...' if len(pattern) > 50 else pattern,
                                'content_preview': line.strip()[:100],
                                'severity': categorize_severity(secret_type),
                            })
    
    return findings

def categorize_severity(secret_type):
    """Categoriza la severidad del secreto encontrado."""
    critical_severity = ['PRIVATE_KEYS', 'AWS_CREDENTIALS', 'GCP_CREDENTIALS', 'DATABASE_CREDENTIALS', 'CUSTOM_PATTERNS']
    high_severity = ['API_KEYS', 'TOKENS', 'ENCRYPTION_KEYS']
    
    if secret_type in critical_severity:
        return 'CRITICAL'
    elif secret_type in high_severity:
        return 'HIGH'
    return 'MEDIUM'

def scan_directory(root_path, output_file=None):
    """Escanea un directorio completo buscando secretos."""
    results = {}
    total_findings = 0
    
    print(f"ðŸ” Iniciando escaneo en: {root_path}")
    print(f"â±ï¸  Timestamp: {datetime.now().isoformat()}")
    print("-" * 80)
    
    for root, dirs, files in os.walk(root_path):
        # Excluir directorios
        dirs[:] = [d for d in dirs if not should_skip_file(os.path.join(root, d))]
        
        for file in files:
            file_path = os.path.join(root, file)
            
            if should_skip_file(file_path):
                continue
            
            findings = detect_secrets_in_file(file_path)
            
            if findings:
                relative_path = os.path.relpath(file_path, root_path)
                results[relative_path] = findings
                total_findings += len(findings)
                
                print(f"\nâš ï¸  {relative_path}")
                for finding in findings:
                    severity_icon = "ðŸ”´" if finding['severity'] == 'CRITICAL' else "ðŸŸ "
                    print(f"  {severity_icon} [{finding['severity']}] LÃ­nea {finding['line']}: {finding['type']}")
                    print(f"     Vista previa: {finding['content_preview']}")
    
    print("\n" + "=" * 80)
    print(f"ðŸ“Š Resumen:")
    print(f"   Total de archivos con hallazgos: {len(results)}")
    print(f"   Total de hallazgos: {total_findings}")
    
    if total_findings > 0:
        critical_count = sum(1 for findings in results.values() for f in findings if f['severity'] == 'CRITICAL')
        high_count = sum(1 for findings in results.values() for f in findings if f['severity'] == 'HIGH')
        print(f"   ðŸ”´ CrÃ­tico: {critical_count}")
        print(f"   ðŸŸ  Alto: {high_count}")
    
    # Guardar resultados en archivo JSON
    if output_file or total_findings > 0:
        output_path = output_file or os.path.join(root_path, 'security-scan-report.json')
        with open(output_path, 'w') as f:
            json.dump({
                'scan_date': datetime.now().isoformat(),
                'scan_path': root_path,
                'total_findings': total_findings,
                'files_with_findings': len(results),
                'results': results
            }, f, indent=2)
        print(f"\nâœ… Reporte guardado en: {output_path}")
    
    return results

def is_git_url(path):
    """Verifica si la ruta es una URL de git."""
    return path.startswith(('http://', 'https://', 'git@'))

def is_file_url(url):
    """Verifica si es una URL de archivo individual (no repositorio)."""
    # Limpiar parÃ¡metros query
    url = url.split('?')[0]
    
    # Si tiene /-/blob/ o /-/raw/ es archivo
    if '/-/blob/' in url or '/-/raw/' in url:
        return True
    # Si tiene /-/tree/ es directorio (considerar como repo)
    if '/-/tree/' in url:
        return False
    # Si termina con extensiÃ³n de archivo es archivo
    if url.endswith(('.env', '.py', '.js', '.yml', '.yaml', '.json', '.sh', '.conf')):
        return True
    # Si termina con .git es repositorio
    if url.endswith('.git'):
        return False
    # Si NO tiene /-/blob/, /-/raw/ y SÃ tiene .git es repositorio
    return False

def get_gitlab_token():
    """Lee el token de GitLab del archivo de configuraciÃ³n."""
    token_paths = [
        os.path.expanduser('~/Documents/GNP/PersonalGitLabToken'),
        os.path.expanduser('~/.gitlab_token'),
        '/home/admin/Documents/GNP/PersonalGitLabToken',
    ]
    
    for token_file in token_paths:
        if os.path.exists(token_file):
            try:
                with open(token_file, 'r') as f:
                    token = f.read().strip()
                    if token:
                        return token
            except:
                pass
    
    return os.environ.get('GITLAB_TOKEN')

def download_file(url, temp_dir):
    """Descarga un archivo individual usando GitLab API."""
    try:
        print(f"ðŸ“¥ Descargando archivo: {url}")
        
        # Limpiar URL de parÃ¡metros query innecesarios
        url = url.split('?')[0]
        
        # Convertir URLs de GitLab blob a API
        if '/-/blob/' in url:
            # Extraer componentes de la URL
            # https://gitlab.com/gitgnp/cotizadores/gae-gnp-danios-config-front-end/-/blob/Celula2/path/to/file.env
            parts = url.split('/-/blob/')
            base_url = parts[0]
            path_parts = parts[1].split('/', 1)
            branch = path_parts[0]
            file_path = path_parts[1] if len(path_parts) > 1 else ''
            
            # Construir URL de API
            project_path = base_url.replace('https://gitlab.com/', '')
            encoded_project = requests.utils.quote(project_path, safe='')
            encoded_file = requests.utils.quote(file_path, safe='')
            url = f"https://gitlab.com/api/v4/projects/{encoded_project}/repository/files/{encoded_file}/raw?ref={branch}"
        
        filename = url.split('/')[-1].split('?')[0] or 'downloaded_file'
        filepath = os.path.join(temp_dir, filename)
        
        # Obtener token de GitLab
        gitlab_token = get_gitlab_token()
        headers = {}
        
        if gitlab_token:
            headers['PRIVATE-TOKEN'] = gitlab_token
        
        # Descargar con requests
        response = requests.get(url, headers=headers, timeout=30)
        response.raise_for_status()
        
        # Verificar que no es error
        if response.status_code >= 400:
            print(f"âŒ Error al descargar (status: {response.status_code})")
            return None
        
        # Guardar archivo
        with open(filepath, 'wb') as f:
            f.write(response.content)
        
        print(f"âœ… Archivo descargado: {filename}")
        return temp_dir
        
    except requests.exceptions.ConnectionError:
        print(f"âŒ Error de conexiÃ³n")
        return None
    except requests.exceptions.Timeout:
        print(f"âŒ Timeout al descargar")
        return None
    except Exception as e:
        print(f"âŒ Error al descargar: {e}")
        return None

def clone_repository(url, temp_dir):
    """Clona un repositorio git en un directorio temporal."""
    try:
        print(f"ðŸ“¦ Clonando repositorio: {url}")
        
        # Limpiar URL de parÃ¡metros query
        url = url.split('?')[0]
        
        # Si es URL de directorio (/-/tree/), convertir a URL del repositorio
        if '/-/tree/' in url:
            # https://gitlab.com/gitgnp/gcp/gke-config-files/-/tree/master/harness-manifests/...
            # â†’ https://gitlab.com/gitgnp/gcp/gke-config-files.git
            base_url = url.split('/-/tree/')[0]
            url = base_url + '.git'
        
        # Intentar HTTPS primero
        clone_url = url
        if not clone_url.endswith('.git'):
            clone_url += '.git'
        
        # Intentar clonar con HTTPS
        result = subprocess.run(
            ['git', 'clone', '--depth', '1', clone_url, temp_dir],
            capture_output=True,
            timeout=300,
            text=True
        )
        
        if result.returncode == 0:
            print(f"âœ… Repositorio clonado exitosamente")
            return True
        
        # Si falla HTTPS y tiene token, intentar con token en la URL
        if 'gitgnp' in url and result.returncode != 0:
            print(f"âš ï¸  HTTPS fallÃ³, intentando con token...")
            gitlab_token = get_gitlab_token()
            if gitlab_token:
                token_url = clone_url.replace('https://gitlab.com/', f'https://oauth2:{gitlab_token}@gitlab.com/')
                result = subprocess.run(
                    ['git', 'clone', '--depth', '1', token_url, temp_dir],
                    capture_output=True,
                    timeout=300,
                    text=True
                )
                if result.returncode == 0:
                    print(f"âœ… Repositorio clonado exitosamente (con token)")
                    return True
        
        if result.returncode != 0:
            print(f"âŒ Error al clonar: {result.stderr[:200]}")
        
        return False
    except subprocess.TimeoutExpired:
        print("âŒ Timeout al clonar el repositorio")
        return False
    except Exception as e:
        print(f"âŒ Error al clonar repositorio: {e}")
        return False

def process_input(input_path, output_file=None):
    """Procesa entrada (URLs o archivos) y realiza el escaneo."""
    
    if is_git_url(input_path):
        # Es una URL
        temp_dir = tempfile.mkdtemp(prefix='secret_scan_')
        print(f"ðŸ“ Directorio temporal: {temp_dir}\n")
        
        try:
            if is_file_url(input_path):
                # Archivo individual
                if not download_file(input_path, temp_dir):
                    return
            else:
                # Repositorio completo
                if not clone_repository(input_path, temp_dir):
                    return
            
            results = scan_directory(temp_dir, output_file)
            
        finally:
            print(f"\nðŸ§¹ Limpiando directorio temporal...")
            shutil.rmtree(temp_dir, ignore_errors=True)
    else:
        # PodrÃ­a ser un archivo local para anÃ¡lisis
        if os.path.isfile(input_path):
            print(f"ðŸ“„ Analizando archivo: {input_path}\n")
            temp_dir = tempfile.mkdtemp(prefix='secret_scan_')
            try:
                import shutil as sh
                sh.copy(input_path, temp_dir)
                results = scan_directory(temp_dir, output_file)
            finally:
                shutil.rmtree(temp_dir, ignore_errors=True)
        else:
            print("âŒ Error: Solo se aceptan URLs de repositorios o archivos individuales")
            print("\nUso:")
            print("  python3 detect-secrets.py https://github.com/usuario/repo.git")
            print("  python3 detect-secrets.py https://gitlab.com/usuario/repo/-/blob/branch/archivo.env")
            print("  python3 detect-secrets.py /ruta/archivo.env")
            sys.exit(1)

if __name__ == '__main__':
    if len(sys.argv) > 1:
        input_path = sys.argv[1]
    else:
        print("Uso:")
        print("  python3 detect-secrets.py /ruta/local")
        print("  python3 detect-secrets.py https://github.com/usuario/repo.git")
        print("  python3 detect-secrets.py /ruta/local /ruta/reporte.json")
        sys.exit(1)
    
    output_file = sys.argv[2] if len(sys.argv) > 2 else None
    
    process_input(input_path, output_file)
